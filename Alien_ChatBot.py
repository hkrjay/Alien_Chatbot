{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "503db7b5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import necessary libraries\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "import nltk\n",
    "from nltk.stem import WordNetLemmatizer\n",
    "import json\n",
    "import pickle\n",
    "import time\n",
    "\n",
    "import numpy as np\n",
    "from tensorflow.keras.models import Sequential\n",
    "from tensorflow.keras.layers import Dense, Activation, Dropout\n",
    "from tensorflow.keras.optimizers import SGD\n",
    "import random\n",
    "from keras.models import load_model\n",
    "\n",
    "# create an object of WordNetLemmatizer\n",
    "lemmatizer = WordNetLemmatizer()\n",
    "\n",
    "# importing the GL Bot corpus file for pre-processing\n",
    "\n",
    "words=[]\n",
    "classes = []\n",
    "documents = []\n",
    "ignore_words = ['?', '!']\n",
    "data_file = open(\"intents.json\",'rb').read()\n",
    "intents = json.loads(data_file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "b9f94f06",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[nltk_data] Downloading package punkt to\n",
      "[nltk_data]     C:\\Users\\kush\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package punkt is already up-to-date!\n",
      "[nltk_data] Downloading package wordnet to\n",
      "[nltk_data]     C:\\Users\\kush\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package wordnet is already up-to-date!\n"
     ]
    }
   ],
   "source": [
    "# preprocessing the json data\n",
    "# tokenization\n",
    "nltk.download('punkt')\n",
    "nltk.download('wordnet')\n",
    "for intent in intents['intents']:\n",
    "    for pattern in intent['patterns']:\n",
    "\n",
    "        #tokenize each word\n",
    "        w = nltk.word_tokenize(pattern)\n",
    "        words.extend(w)\n",
    "        #add documents in the corpus\n",
    "        documents.append((w, intent['tag']))\n",
    "\n",
    "        # add to our classes list\n",
    "        if intent['tag'] not in classes:\n",
    "            classes.append(intent['tag'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "a5d59642",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "924 documents\n",
      "257 classes ['     Support Vector Machine', '   Decision Trees', '  Perceptron', '  Regularization in Machine Learning', '  applications of supervised learning', '  basic data structures', \" 'action' in reinforcement learning\", \" 'agent' in reinforcement learning\", \" 'value' in reinforcement learning\", ' Classification model', ' Gradient Descent', ' Inductive Logic Programming', ' Polynomial Regression', ' Regularization', ' Ridge Regression technique', ' Types of machine learning', ' advantages of using Polynomial Regression over Linear Regression', ' applications of self-supervised learning', ' components of Bayesian logic program', ' difference between heuristic for rule learning and heuristics', ' disadvantages of supervised learning', ' imbalanced datasheet', ' issues to consider in supervised learning', ' standard supervised learning', 'A/B Testing', 'Algorithm techniques in Machine Learning', 'Alien_sp', 'Appreciation', 'Apriori algorithm', 'Areas of Problems', 'BiasML', 'BinaryClass', 'ClassDef', 'Class_Tasks', 'Classification_algo', 'Concern', 'Confusion_Matrix', 'Criticism', 'Curse of dimensionality', 'Data Wrangling', 'Deep_Learning', 'Density based lagorithms', 'Dimensionality Reduction', 'ECLAT algorithm', 'EDA', 'ETA Prediction', 'Eg_Class', 'Ensemble', 'Exp_TP_TN_FP_FN', 'FCM algorithm', 'FP growth algorithm', 'FP tree structure by Han', 'Face Clustering Pipeline', 'Friend Tag suggestion', 'Fzzy c-Means', 'Hierarchical clustering', 'Hypothesis Generation', 'Inductive Logic Programming in Machine Learning', 'K-Means clustering', 'K-Nearest Neighbor Algorithm', 'K-Nearest Neighbors', 'Lazy learning algorithm', 'LifeQueries', 'Linear Discriminant Analysis', 'LowBi_HighVar', 'MCC', 'MLC', 'ML_DL', 'Machine Learning in self-driving cars', 'Market Analysis', 'Model Selection in Machine Learning', 'Neural_Network', 'Noise', 'Overfitting', 'Overfitting in laymen term', 'PAC Learning', 'PATTERN RECOGNITION', 'PCA or auto encoder', 'Para', 'Personal', 'Please', 'Pop_algoMC', 'Prec_Rec', 'Realtional Evaluation', 'Recommended Systems', 'Reg', 'Reg_Eg', 'Role of machine learning in voice assistants', 'SVM', 'Sampling', 'Sequence Learning process', 'SupLearn', 'Support Vector Machine', 'Terms', 'Underfitting in laymen term', 'Variance', 'Why overfitting happens', 'Z Score', 'advanatges of eclat algorithm', 'advantages and disadvanatages of reinforcement learning', 'advantages of k-means algorithm', 'advantages of knn algorithm', 'advantages of supervised learning', 'adverse_drug', 'agglomerative clustering', 'algorithm for building a fp tree', 'algorithm for mining a fp tree', 'algorithm independent machine learning', 'algorithm is used best for supervised learning', 'algorithms for association rule generation', 'algorithms of Machine Learning', 'algorithms used by neural networks.', 'applications', 'applications of association rules', 'applications of reinforcement learning', 'applications of unsupervised machine learning', 'ask', 'association', 'avoid Bias', 'avoid overfitting', 'bayesian networks', 'best practices for supervised learning', 'blood_pressure', 'blood_pressure_search', 'book_sp', 'building_a_model', 'calibration in Supervised Learning', 'choose_algo', 'classification problems', 'classifier', 'classifier in machine learning', 'clustering', 'clustering in short', 'clustering methods', 'comparison between K-Means and FCM clustering', 'country_sp', 'creation_sp', 'cross-validation?', 'data normalization', 'dendrogram', 'detection of fake users using unsupervised learning', 'diff_DPDPDW', 'diff_RF_GB', 'diff_classreg', 'difference between Data Mining and Machine learning', 'difference between artificial learning and machine learning', 'differences between K-Means and Hierarchical clustering', 'differences between KNN and K-means clustering', 'differences between supervised and unsupervised machine learning', 'different types of Learning/ Training models in ML', 'dimension reduction in machine learning', 'disadvantages of knn algorithm', 'disadvantages of unsupervised machine learning', 'disadvantges of using k-means', 'distrbutionMC', 'distributionBC', 'ensemble learning?', 'evil_sp', 'example of unsupervised learning algorithm', 'examples of clustering applications', 'exclusive clustering', 'face clustering and its realtion  unsupervised learning', 'fail_sp', 'features and labels', 'formulation of a reinforcement problem', 'func_SL', 'gandhi_sp', 'genetic programming', 'gf_sp ', 'gf_sp_again', 'good clustering', 'goodbye', 'gradient descent methods converge', 'greeting', 'grid-based clsutering methods', 'hierarchical clustering based method', 'hospital_search', 'human_sp', 'hurt_sp', 'imbalanced_classification', 'importance of unsupervised learning', 'inductive machine learning', 'kernel SVM', 'key difference between supervised and unsupervised learning', 'key terms realted to reinforcement learning', 'labeled and unlabeled data', 'limitations of apriori algorithm', 'love_sp', 'major clustering techniques', 'mark_sp', 'meth_SVM', 'methods of moments', 'missing data', 'ml', 'model selection', 'model-based learning', 'need of clustering', 'need of unsupervised learning', 'neural networks algorithms', 'obey_sp', 'odds ratio', 'options', 'overfitting', 'overlapping clustering', 'partitioning clustering method', 'past_sp', 'pharmacy_search', 'policy-based reinforcement learning', 'pop_algo', 'principle of Unsupervised Data Augmentation', 'probabilistic clustering', 'python3 modules to implement unsupervised face clustering pipeline', 'q-value or action-value', 'ques', 'reinforcement learning', 'reinforcement learning algorithms', 'relation between reinforcement learning and machine learning', 'resources to learn reinforcement learning', 'sad_sp', 'sanjoy_sp', 'save_yourself_sp', 'self supervised learning', 'sing_happy_birthday_sp', 'sing_song_sp', 'smart_sp', 'solution of cartpole problem', 'standard_approach', 'techniques for anomaly detection on a dataset', 'terms related to association rules', 'thanks', 'trade-off between accuracy and interpretability', 'traintest', 'types of clustering methods', 'types of reinforcement learning', 'types of unsupervised learning', 'types_SL', 'types_reg', 'unsupervised learning', 'unsupervised learning algorithm for categorical data', 'unsupervised learning algorithms', 'unsupervised learning work', 'use of KNN algorithm', 'use of auto encoder', 'use of unsupervised clustering models', 'use of unsupervised learning', 'use_reg', 'using Polynomial Regression', 'value-based learning', 'various approaches for machine learning', 'why rl is hard', 'will_love_sp', 'working of GMaps', 'working of apriori algorithm', 'working of eclat algorithm', 'working of k-means algorithm', 'working of knn algorithm', 'working of unsupervised face clustering pipeline']\n",
      "647 unique lemmatized words [\"'\", \"'action\", \"'ll\", \"'m\", \"'s\", \"'value\", '(', ')', ',', '.', ':', 'a', 'a/b', 'abnormal', 'about', 'according', 'accuracy', 'act', 'action', 'action-value', 'adatset', 'advanategeous', 'advanatges', 'advantage', 'adverse', 'again', 'agent', 'agglomerative', 'ai', 'aim', 'alexa', 'algorithm', 'algorthm', 'alien', 'alienilable', 'all', 'alone', 'already', 'always', 'am', 'amazing', 'an', 'analysing', 'analysis', 'and', 'anomaly', 'any', 'anyone', 'apllied', 'application', 'applied', 'approach', 'apriori', 'are', 'area', 'arises', 'arrival', 'artificial', 'assistant', 'association', 'at', 'attention', 'augmentation', 'auto', 'automate', 'automatic', 'avial', 'avoid', 'avoiding', 'awesome', 'bad', 'based', 'basic', 'bayesian', 'bayesiann', 'be', 'been', 'behavior', 'behaviour', 'behind', 'being', 'benefit', 'best', 'better', 'between', 'bias', 'binary', 'birthday', 'blank', 'blood', 'book', 'boosting', 'bot', 'bothering', 'boyfriend', 'brief', 'briefly', 'build', 'building', 'built', 'by', 'bye', 'c-means', 'calculation', 'calibration', 'call', 'can', 'car', 'cartpole', 'categorical', 'categorize', 'category', 'causing', 'characteristic', 'chatbot', 'chatting', 'check', 'choose', 'classification', 'classifier', 'classify', 'classiification', 'cling', 'clsutering', 'cluster', 'clustering', 'clutering', 'command', 'common', 'commonly', 'compare', 'complete', 'component', 'compromise', 'confusion', 'connected', 'conquer', 'consider', 'considered', 'construct', 'context', 'converge', 'could', 'country', 'created', 'creating', 'creator', 'cringe', 'cross', 'cross-validation', 'curse', 'customer', 'data', 'dataset', 'datasheet', 'day', 'decision', 'deep', 'define', 'defnition', 'demerit', 'dendrogram', 'density', 'descent', 'describe', 'detail', 'detect', 'detecting', 'detection', 'detetc', 'developer', 'diadvantages', 'difference', 'different', 'differentiate', 'dimension', 'dimensionality', 'disadalienntages', 'disadvantage', 'disadvantegeous', 'disadvantges', 'discus', 'disdalienntages', 'distinguish', 'distribution', 'do', 'doe', 'done', 'dont', 'driving', 'drug', 'due', 'each', 'ear', 'earth', 'eclat', 'eda', 'encoder', 'encoders', 'engineer', 'ensamble', 'ensemble', 'entry', 'estimated', 'eta', 'evaluation', 'ever', 'evil', 'example', 'exlclusive', 'explain', 'extract', 'extracting', 'face', 'facebook', 'failed', 'failing', 'fake', 'false', 'favourite', 'fcm', 'feature', 'feel', 'feeling', 'field', 'find', 'finding', 'first', 'for', 'forest', 'forget', 'formulate', 'four', 'fp', 'frequent', 'frequently', 'fried', 'friend', 'from', 'function', 'fuzzy', 'gandhi', 'general', 'generalized', 'generate', 'generating', 'generation', 'genetic', 'get', 'getting', 'girlfriend', 'give', 'given', 'going', 'good', 'good-for-nothing', 'goodbye', 'google', 'got', 'gradient', 'grid', 'growth', 'ha', 'had', 'han', 'handle', 'happens', 'happiness', 'happy', 'hard', 'have', 'having', 'hello', 'help', 'helpful', 'helping', 'heuristic', 'hey', 'hi', 'hierarchical', 'high', 'hii', 'history', 'hobby', 'hola', 'hope', 'hospital', 'how', 'human', 'hurt', 'hypothesis', 'i', 'ica', 'id', 'idea', 'if', 'ill', 'imbalanced', 'implement', 'implementation', 'implementing', 'importance', 'important', 'in', 'independent', 'inductive', 'information', 'instance', 'interpretability', 'invented', 'is', 'issue', 'it', 'just', 'k-means', 'k-nearest', 'kernel', 'key', 'kill', 'kind', 'knn', 'know', 'kpca', 'label', 'labeled', 'laering', 'language', 'later', 'layman', 'lazy', 'lda', 'learn', 'learning', 'learning/', 'leraning', 'library', 'life', 'like', 'limitation', 'linear', 'list', 'load', 'locate', 'log', 'logic', 'looking', 'lookup', 'loss', 'lost', 'love', 'low', 'machine', 'mad', 'made', 'mahatma', 'major', 'make', 'management', 'map', 'mark', 'market', 'marketing', 'marry', 'matrix', 'me', 'mean', 'meaning', 'mechanism', 'mention', 'messed', 'method', 'million', 'mining', 'miss', 'missing', 'mistake', 'ml', 'model', 'model-based', 'modelling', 'module', 'moment', 'more', 'most', 'movie', 'multi-class', 'multi-label', 'my', 'name', 'nation', 'nearby', 'need', 'negative', 'neighbor', 'network', 'neural', 'newral', 'next', 'nice', 'no', 'noise', 'non-parametric', 'normal', 'normalization', 'not', 'obey', 'odds', 'of', 'offered', 'ok', 'okay', 'on', 'one', 'open', 'opinion', 'optimal', 'or', 'other', 'over', 'overfitting', 'overlapping', 'overview', 'pac', 'parametric', 'partitioning', 'past', 'patient', 'pator', 'pattern', 'pca', 'people', 'perceptron', 'pharmacy', 'phase', 'phrase', 'pipeline', 'play', 'played', 'please', 'point', 'policy-based', 'polinomial', 'polynomial', 'popular', 'positive', 'possibility', 'possible', 'powerful', 'practical', 'practice', 'precision', 'prediction', 'prefferable', 'prefferd', 'preprocessing', 'pressure', 'prevent', 'principle', 'probabilistic', 'probability', 'problem', 'process', 'processing', 'product', 'program', 'programming', 'propose', 'protect', 'provide', 'python', 'q-value', 'random', 'ratio', 'reaction', 'reagrd', 'realted', 'realtion', 'reason', 'recall', 'recognition', 'recommended', 'reducing', 'reduction', 'referred', 'regard', 'regression', 'regularization', 'reinforcement', 'reinforcemnet', 'related', 'relational', 'remember', 'required', 'requirement', 'resolved', 'resource', 'result', 'ridge', 'rl', 'robot', 'robotics', 'role', 'rough', 'route', 'rude', 'rule', 'sad', 'same', 'sampling', 'sanjoy', 'save', 'say', 'score', 'search', 'searching', 'second', 'see', 'selection', 'self', 'self-driving', 'sequence', 'sequential', 'set', 'short', 'should', 'show', 'significant', 'sing', 'siri', 'size', 'smart', 'smarter', 'so', 'software', 'solution', 'solving', 'some', 'somebody', 'someone', 'something', 'sometimes', 'song', 'stage', 'standard', 'stareted', 'state', 'step', 'strategy', 'structure', 'study', 'stupid', 'such', 'suffering', 'suggest', 'suggestion', 'suitable', 'supervised', 'support', 'svm', 'system', 'tagging', 'take', 'taken', 'talk', 'task', 'technique', 'tell', 'term', 'terminator', 'terminology', 'test', 'testing', 'than', 'thank', 'thanks', 'that', 'the', 'there', 'think', 'three', 'till', 'time', 'tired', 'to', 'today', 'totally', 'tough', 'trade-off', 'traffic', 'training', 'transfer', 'tree', 'true', 'tutorial', 'two', 'type', 'uased', 'uda', 'uinsupervised', 'underfitting', 'understand', 'unlabeled', 'unsupervised', 'unsupervsied', 'up', 'us', 'use', 'used', 'useless', 'user', 'using', 'usupervised', 'v', 'validation', 'value', 'value-based', 'variance', 'vector', 'very', 'voice', 'want', 'way', 'we', 'well', 'what', 'when', 'where', 'which', 'who', 'why', 'wih', 'will', 'with', 'word', 'work', 'working', 'world', 'wotrking', 'wrangling', 'wrong', 'you', 'your', 'yourself', 'z', 'zuckerberg', '‘', '’']\n"
     ]
    }
   ],
   "source": [
    "# lemmatize, lower each word and remove duplicates\n",
    "\n",
    "words = [lemmatizer.lemmatize(w.lower()) for w in words if w not in ignore_words]\n",
    "words = sorted(list(set(words)))\n",
    "\n",
    "# sort classes\n",
    "classes = sorted(list(set(classes)))\n",
    "\n",
    "# documents = combination between patterns and intents\n",
    "print (len(documents), \"documents\")\n",
    "\n",
    "# classes = intents\n",
    "print (len(classes), \"classes\", classes)\n",
    "\n",
    "# words = all words, vocabulary\n",
    "print (len(words), \"unique lemmatized words\", words)\n",
    "\n",
    "# creating a pickle file to store the Python objects which we will use while predicting\n",
    "pickle.dump(words,open('words.pkl','wb')) \n",
    "pickle.dump(classes,open('classes.pkl','wb'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "8651c556",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training data created\n"
     ]
    }
   ],
   "source": [
    "# create our training data\n",
    "training = []\n",
    "\n",
    "# create an empty array for our output\n",
    "output_empty = [0] * len(classes)\n",
    "\n",
    "# training set, bag of words for each sentence\n",
    "for doc in documents:\n",
    "    # initialize our bag of words\n",
    "    bag = []\n",
    "    # list of tokenized words for the pattern\n",
    "    pattern_words = doc[0]\n",
    "   \n",
    "    # lemmatize each word - create base word, in attempt to represent related words\n",
    "    pattern_words = [lemmatizer.lemmatize(word.lower()) for word in pattern_words]\n",
    "    \n",
    "    # create our bag of words array with 1, if word match found in current pattern\n",
    "    for w in words:\n",
    "        bag.append(1) if w in pattern_words else bag.append(0)\n",
    "    # output is a '0' for each tag and '1' for current tag (for each pattern)\n",
    "    output_row = list(output_empty)\n",
    "    output_row[classes.index(doc[1])] = 1\n",
    "    training.append([bag, output_row])\n",
    "\n",
    "# shuffle features and converting it into numpy arrays\n",
    "random.shuffle(training)\n",
    "training = np.array(training)\n",
    "\n",
    "# create train and test lists\n",
    "train_x = list(training[:,0])\n",
    "train_y = list(training[:,1])\n",
    "\n",
    "print(\"Training data created\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "5ccc919e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 5.5536 - accuracy: 0.0065\n",
      "Epoch 2/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 5.5051 - accuracy: 0.0184\n",
      "Epoch 3/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 5.4425 - accuracy: 0.0216\n",
      "Epoch 4/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 5.3344 - accuracy: 0.0227\n",
      "Epoch 5/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 5.1584 - accuracy: 0.0379\n",
      "Epoch 6/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 4.9030 - accuracy: 0.0703\n",
      "Epoch 7/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 4.6157 - accuracy: 0.0758\n",
      "Epoch 8/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 4.2749 - accuracy: 0.1245\n",
      "Epoch 9/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 3.9849 - accuracy: 0.1429\n",
      "Epoch 10/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 3.7733 - accuracy: 0.1688\n",
      "Epoch 11/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 3.5619 - accuracy: 0.2035\n",
      "Epoch 12/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 3.4173 - accuracy: 0.2078\n",
      "Epoch 13/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 3.1949 - accuracy: 0.2489\n",
      "Epoch 14/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 3.0693 - accuracy: 0.2781\n",
      "Epoch 15/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 2.9289 - accuracy: 0.2835\n",
      "Epoch 16/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.8895 - accuracy: 0.2835\n",
      "Epoch 17/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.6907 - accuracy: 0.3128\n",
      "Epoch 18/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.6174 - accuracy: 0.3333\n",
      "Epoch 19/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.5729 - accuracy: 0.3463\n",
      "Epoch 20/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.4865 - accuracy: 0.3496\n",
      "Epoch 21/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.3338 - accuracy: 0.3939\n",
      "Epoch 22/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.4166 - accuracy: 0.3615\n",
      "Epoch 23/200\n",
      "185/185 [==============================] - 0s 3ms/step - loss: 2.3177 - accuracy: 0.3853\n",
      "Epoch 24/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.2478 - accuracy: 0.4156\n",
      "Epoch 25/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.2184 - accuracy: 0.4123\n",
      "Epoch 26/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.0690 - accuracy: 0.4286\n",
      "Epoch 27/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.0421 - accuracy: 0.4394\n",
      "Epoch 28/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.0380 - accuracy: 0.4264\n",
      "Epoch 29/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 2.0238 - accuracy: 0.4416\n",
      "Epoch 30/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.8701 - accuracy: 0.4816\n",
      "Epoch 31/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.9558 - accuracy: 0.4448\n",
      "Epoch 32/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.8836 - accuracy: 0.4665\n",
      "Epoch 33/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.9276 - accuracy: 0.4708\n",
      "Epoch 34/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.9669 - accuracy: 0.4535\n",
      "Epoch 35/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7976 - accuracy: 0.5152\n",
      "Epoch 36/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.8435 - accuracy: 0.4913\n",
      "Epoch 37/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7831 - accuracy: 0.4957\n",
      "Epoch 38/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.9280 - accuracy: 0.4578\n",
      "Epoch 39/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7466 - accuracy: 0.5173\n",
      "Epoch 40/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7421 - accuracy: 0.5087\n",
      "Epoch 41/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6646 - accuracy: 0.5400\n",
      "Epoch 42/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7018 - accuracy: 0.5260\n",
      "Epoch 43/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6594 - accuracy: 0.5411\n",
      "Epoch 44/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6460 - accuracy: 0.5390\n",
      "Epoch 45/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5758 - accuracy: 0.5617\n",
      "Epoch 46/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6909 - accuracy: 0.5292\n",
      "Epoch 47/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6458 - accuracy: 0.5390\n",
      "Epoch 48/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6991 - accuracy: 0.5346\n",
      "Epoch 49/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6782 - accuracy: 0.5368\n",
      "Epoch 50/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6954 - accuracy: 0.5152\n",
      "Epoch 51/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7458 - accuracy: 0.5335\n",
      "Epoch 52/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7542 - accuracy: 0.5227\n",
      "Epoch 53/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6701 - accuracy: 0.5281\n",
      "Epoch 54/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5742 - accuracy: 0.5574\n",
      "Epoch 55/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5960 - accuracy: 0.5747\n",
      "Epoch 56/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6253 - accuracy: 0.5574\n",
      "Epoch 57/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5957 - accuracy: 0.5357\n",
      "Epoch 58/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5674 - accuracy: 0.5714\n",
      "Epoch 59/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5027 - accuracy: 0.5790\n",
      "Epoch 60/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6237 - accuracy: 0.5541\n",
      "Epoch 61/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6112 - accuracy: 0.5639\n",
      "Epoch 62/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6007 - accuracy: 0.5649\n",
      "Epoch 63/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6268 - accuracy: 0.5509\n",
      "Epoch 64/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5820 - accuracy: 0.5411\n",
      "Epoch 65/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5922 - accuracy: 0.5628\n",
      "Epoch 66/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6199 - accuracy: 0.5682\n",
      "Epoch 67/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5076 - accuracy: 0.5844\n",
      "Epoch 68/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5506 - accuracy: 0.5703\n",
      "Epoch 69/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5312 - accuracy: 0.5898\n",
      "Epoch 70/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.4832 - accuracy: 0.5887\n",
      "Epoch 71/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6032 - accuracy: 0.5584\n",
      "Epoch 72/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5599 - accuracy: 0.5649\n",
      "Epoch 73/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.4796 - accuracy: 0.5877\n",
      "Epoch 74/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5127 - accuracy: 0.5736\n",
      "Epoch 75/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5147 - accuracy: 0.5887\n",
      "Epoch 76/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.4511 - accuracy: 0.6061\n",
      "Epoch 77/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5260 - accuracy: 0.5866\n",
      "Epoch 78/200\n",
      "185/185 [==============================] - 0s 3ms/step - loss: 1.4854 - accuracy: 0.5736\n",
      "Epoch 79/200\n",
      "185/185 [==============================] - 0s 3ms/step - loss: 1.5917 - accuracy: 0.5617\n",
      "Epoch 80/200\n",
      "185/185 [==============================] - 0s 3ms/step - loss: 1.5369 - accuracy: 0.6006\n",
      "Epoch 81/200\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "185/185 [==============================] - 0s 3ms/step - loss: 1.4669 - accuracy: 0.5920\n",
      "Epoch 82/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6700 - accuracy: 0.5595\n",
      "Epoch 83/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5063 - accuracy: 0.5812\n",
      "Epoch 84/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5374 - accuracy: 0.5866\n",
      "Epoch 85/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5943 - accuracy: 0.5682\n",
      "Epoch 86/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5846 - accuracy: 0.5801\n",
      "Epoch 87/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6000 - accuracy: 0.5682\n",
      "Epoch 88/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.4659 - accuracy: 0.6061\n",
      "Epoch 89/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5536 - accuracy: 0.5812\n",
      "Epoch 90/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6467 - accuracy: 0.5574\n",
      "Epoch 91/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5542 - accuracy: 0.5660\n",
      "Epoch 92/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5704 - accuracy: 0.5758\n",
      "Epoch 93/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5028 - accuracy: 0.5952\n",
      "Epoch 94/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5995 - accuracy: 0.5823\n",
      "Epoch 95/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.3631 - accuracy: 0.6234\n",
      "Epoch 96/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7154 - accuracy: 0.5660\n",
      "Epoch 97/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5816 - accuracy: 0.5768\n",
      "Epoch 98/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6015 - accuracy: 0.5649\n",
      "Epoch 99/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.4534 - accuracy: 0.6006\n",
      "Epoch 100/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5711 - accuracy: 0.5963\n",
      "Epoch 101/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6276 - accuracy: 0.5660\n",
      "Epoch 102/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6826 - accuracy: 0.5498\n",
      "Epoch 103/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6255 - accuracy: 0.5725\n",
      "Epoch 104/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7320 - accuracy: 0.5552\n",
      "Epoch 105/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5318 - accuracy: 0.5812\n",
      "Epoch 106/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5799 - accuracy: 0.5833\n",
      "Epoch 107/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5862 - accuracy: 0.6039\n",
      "Epoch 108/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6226 - accuracy: 0.5823\n",
      "Epoch 109/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5433 - accuracy: 0.5974\n",
      "Epoch 110/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6896 - accuracy: 0.5693\n",
      "Epoch 111/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6332 - accuracy: 0.5844\n",
      "Epoch 112/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5024 - accuracy: 0.6169\n",
      "Epoch 113/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6767 - accuracy: 0.5660\n",
      "Epoch 114/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5834 - accuracy: 0.5768\n",
      "Epoch 115/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5254 - accuracy: 0.5823\n",
      "Epoch 116/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5279 - accuracy: 0.5996\n",
      "Epoch 117/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5602 - accuracy: 0.6093\n",
      "Epoch 118/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5613 - accuracy: 0.5920\n",
      "Epoch 119/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5994 - accuracy: 0.6006\n",
      "Epoch 120/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.5013 - accuracy: 0.6028\n",
      "Epoch 121/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5967 - accuracy: 0.5801\n",
      "Epoch 122/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6156 - accuracy: 0.5909\n",
      "Epoch 123/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6146 - accuracy: 0.5758\n",
      "Epoch 124/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5908 - accuracy: 0.5584\n",
      "Epoch 125/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.4870 - accuracy: 0.6255\n",
      "Epoch 126/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5899 - accuracy: 0.5996\n",
      "Epoch 127/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6518 - accuracy: 0.5649\n",
      "Epoch 128/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6513 - accuracy: 0.5563\n",
      "Epoch 129/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5177 - accuracy: 0.5985\n",
      "Epoch 130/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5225 - accuracy: 0.5942\n",
      "Epoch 131/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5606 - accuracy: 0.6071\n",
      "Epoch 132/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5341 - accuracy: 0.5931\n",
      "Epoch 133/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.4846 - accuracy: 0.6071\n",
      "Epoch 134/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6661 - accuracy: 0.5996\n",
      "Epoch 135/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6579 - accuracy: 0.5703\n",
      "Epoch 136/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6476 - accuracy: 0.5823\n",
      "Epoch 137/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6501 - accuracy: 0.5844\n",
      "Epoch 138/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6532 - accuracy: 0.5801\n",
      "Epoch 139/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6382 - accuracy: 0.5747\n",
      "Epoch 140/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5108 - accuracy: 0.5952\n",
      "Epoch 141/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.4604 - accuracy: 0.6223\n",
      "Epoch 142/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5735 - accuracy: 0.6082\n",
      "Epoch 143/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6703 - accuracy: 0.5963\n",
      "Epoch 144/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6630 - accuracy: 0.5931\n",
      "Epoch 145/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6524 - accuracy: 0.6039\n",
      "Epoch 146/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6934 - accuracy: 0.5833\n",
      "Epoch 147/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7039 - accuracy: 0.5833\n",
      "Epoch 148/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7036 - accuracy: 0.5812\n",
      "Epoch 149/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6322 - accuracy: 0.5812\n",
      "Epoch 150/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7880 - accuracy: 0.5747\n",
      "Epoch 151/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.5994 - accuracy: 0.5931\n",
      "Epoch 152/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6329 - accuracy: 0.5931\n",
      "Epoch 153/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.7729 - accuracy: 0.5790\n",
      "Epoch 154/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6272 - accuracy: 0.5725\n",
      "Epoch 155/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6935 - accuracy: 0.5898\n",
      "Epoch 156/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6503 - accuracy: 0.5823\n",
      "Epoch 157/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6409 - accuracy: 0.5823\n",
      "Epoch 158/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6306 - accuracy: 0.5909\n",
      "Epoch 159/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.8392 - accuracy: 0.5628\n",
      "Epoch 160/200\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7136 - accuracy: 0.5736\n",
      "Epoch 161/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.7395 - accuracy: 0.5671\n",
      "Epoch 162/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6557 - accuracy: 0.5768\n",
      "Epoch 163/200\n",
      "185/185 [==============================] - 1s 5ms/step - loss: 1.5903 - accuracy: 0.5952\n",
      "Epoch 164/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.5724 - accuracy: 0.6061\n",
      "Epoch 165/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6757 - accuracy: 0.5703\n",
      "Epoch 166/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.7618 - accuracy: 0.5682\n",
      "Epoch 167/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6688 - accuracy: 0.5855\n",
      "Epoch 168/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6539 - accuracy: 0.6039\n",
      "Epoch 169/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.7324 - accuracy: 0.5898\n",
      "Epoch 170/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6470 - accuracy: 0.5931\n",
      "Epoch 171/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6203 - accuracy: 0.5963\n",
      "Epoch 172/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6673 - accuracy: 0.5931\n",
      "Epoch 173/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7130 - accuracy: 0.5801\n",
      "Epoch 174/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.7069 - accuracy: 0.5768\n",
      "Epoch 175/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6728 - accuracy: 0.5887\n",
      "Epoch 176/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6952 - accuracy: 0.5747\n",
      "Epoch 177/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.7763 - accuracy: 0.5736\n",
      "Epoch 178/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.8982 - accuracy: 0.5639\n",
      "Epoch 179/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6741 - accuracy: 0.5877\n",
      "Epoch 180/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6993 - accuracy: 0.5963\n",
      "Epoch 181/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.8290 - accuracy: 0.5509\n",
      "Epoch 182/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.9034 - accuracy: 0.5639\n",
      "Epoch 183/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6772 - accuracy: 0.5812\n",
      "Epoch 184/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.8696 - accuracy: 0.5606\n",
      "Epoch 185/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7195 - accuracy: 0.5887\n",
      "Epoch 186/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.7636 - accuracy: 0.5823\n",
      "Epoch 187/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6216 - accuracy: 0.5942\n",
      "Epoch 188/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.8061 - accuracy: 0.5942\n",
      "Epoch 189/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6780 - accuracy: 0.5693\n",
      "Epoch 190/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7228 - accuracy: 0.5779\n",
      "Epoch 191/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6201 - accuracy: 0.5974\n",
      "Epoch 192/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.7497 - accuracy: 0.5725\n",
      "Epoch 193/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.5883 - accuracy: 0.6006\n",
      "Epoch 194/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.6791 - accuracy: 0.5866\n",
      "Epoch 195/200\n",
      "185/185 [==============================] - 1s 4ms/step - loss: 1.5271 - accuracy: 0.6093\n",
      "Epoch 196/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.8048 - accuracy: 0.5866\n",
      "Epoch 197/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6280 - accuracy: 0.6006\n",
      "Epoch 198/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.6542 - accuracy: 0.6028\n",
      "Epoch 199/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.8171 - accuracy: 0.5844\n",
      "Epoch 200/200\n",
      "185/185 [==============================] - 1s 3ms/step - loss: 1.8207 - accuracy: 0.5898\n",
      "\n",
      "\n",
      "**************************************************\n",
      "\n",
      "Model Created Successfully!\n"
     ]
    }
   ],
   "source": [
    "# Create NN model to predict the responses\n",
    "model = Sequential()\n",
    "model.add(Dense(128, input_shape=(len(train_x[0]),), activation='relu'))\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(64, activation='relu'))\n",
    "model.add(Dropout(0.5))\n",
    "model.add(Dense(len(train_y[0]), activation='softmax'))\n",
    "\n",
    "# Compile model. Stochastic gradient descent with Nesterov accelerated gradient gives good results for this model\n",
    "sgd = SGD(learning_rate=0.01, decay=1e-6, momentum=0.9, nesterov=True)\n",
    "model.compile(loss='categorical_crossentropy', optimizer=sgd, metrics=['accuracy'])\n",
    "\n",
    "#fitting and saving the model \n",
    "hist = model.fit(np.array(train_x), np.array(train_y), epochs=200, batch_size=5, verbose=1)\n",
    "model.save('chatbot.h5', hist) # we will pickle this model to use in the future\n",
    "print(\"\\n\")\n",
    "print(\"*\"*50)\n",
    "print(\"\\nModel Created Successfully!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "ee6ff5f5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# load the saved model file\n",
    "model = load_model('chatbot.h5')\n",
    "intents = json.loads(open(\"intents.json\",'rb').read())\n",
    "words = pickle.load(open('words.pkl','rb'))\n",
    "classes = pickle.load(open('classes.pkl','rb'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "c288d994",
   "metadata": {},
   "outputs": [],
   "source": [
    "def clean_up_sentence(sentence):\n",
    "\n",
    "    # tokenize the pattern - split words into array\n",
    "    sentence_words = nltk.word_tokenize(sentence)\n",
    "    \n",
    "    # stem each word - create short form for word\n",
    "    sentence_words = [lemmatizer.lemmatize(word.lower()) for word in sentence_words]\n",
    "    return sentence_words\n",
    "\n",
    "\n",
    "# return bag of words array: 0 or 1 for each word in the bag that exists in the sentence\n",
    "\n",
    "def bow(sentence, words, show_details=True):\n",
    "\n",
    "    # tokenize the pattern\n",
    "    sentence_words = clean_up_sentence(sentence)\n",
    "\n",
    "    # bag of words - matrix of N words, vocabulary matrix\n",
    "    bag = [0]*len(words) \n",
    "    for s in sentence_words:\n",
    "        for i,w in enumerate(words):\n",
    "            if w == s: \n",
    "               \n",
    "                # assign 1 if current word is in the vocabulary position\n",
    "                bag[i] = 1\n",
    "                if show_details:\n",
    "                    print (\"found in bag: %s\" % w)\n",
    "    return(np.array(bag))\n",
    "\n",
    "def predict_class(sentence, model):\n",
    "   \n",
    "    # filter out predictions below a threshold\n",
    "    p = bow(sentence, words,show_details=False)\n",
    "    res = model.predict(np.array([p]))[0]\n",
    "    error = 0.25\n",
    "    results = [[i,r] for i,r in enumerate(res) if r>error]\n",
    "    \n",
    "    # sort by strength of probability\n",
    "    results.sort(key=lambda x: x[1], reverse=True)\n",
    "    return_list = []\n",
    "    \n",
    "    for r in results:\n",
    "        return_list.append({\"intent\": classes[r[0]], \"probability\": str(r[1])})\n",
    "    return return_list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "9b212d62",
   "metadata": {},
   "outputs": [],
   "source": [
    "# function to get the response from the model\n",
    "\n",
    "def getResponse(ints, intents_json):\n",
    "    tag = ints[0]['intent']\n",
    "    list_of_intents = intents_json['intents']\n",
    "    for i in list_of_intents:\n",
    "        if(i['tag']== tag):\n",
    "            result = random.choice(i['responses'])\n",
    "            break\n",
    "            \n",
    "    return result\n",
    "\n",
    "# function to predict the class and get the response\n",
    "\n",
    "def chatbot_response(text):\n",
    "    ints = predict_class(text, model)\n",
    "    res = getResponse(ints, intents)\n",
    "    return res"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "00b56545",
   "metadata": {},
   "outputs": [],
   "source": [
    "from inspect import CO_OPTIMIZED\n",
    "import time\n",
    "from multiprocessing import RLock\n",
    "from GuessNumberGame import GuessNumGame\n",
    "from calculation_game import calgame\n",
    "from countdowntime import countdown\n",
    "from hangman import Hangman\n",
    "from RockPaperScissor import RPS\n",
    "import Alarm_clock\n",
    "import show_calender\n",
    "import stopwatch\n",
    "import countdowntime\n",
    "from play_music import Music\n",
    "\n",
    "def Crazy_list():\n",
    "    print(\"\\nFetching List...\\n\")\n",
    "    time.sleep(2)\n",
    "\n",
    "    print(\"1: Play Games\")\n",
    "    print(\"2: Set Alarm Clock\")\n",
    "    print(\"3: Show Calender\")\n",
    "    print(\"4: CountDownTimer\")\n",
    "    print(\"5: Listen Music\\n\")\n",
    "\n",
    "    choice=int(input(\"Enter Your Choice: \"))\n",
    "    if 1<=choice<=5:\n",
    "        if choice==1:\n",
    "            GuessNumGame()\n",
    "            ask=input(\"would you like to continue: yes/no: \")\n",
    "            if ask=='yes':\n",
    "                Crazy_list()\n",
    "            else: return\n",
    "        elif choice==2:\n",
    "            Alarm_clock.Alarm()\n",
    "            ask=input(\"would you like to continue: yes/no: \")\n",
    "            if ask=='yes':\n",
    "                Crazy_list()\n",
    "            else: return\n",
    "        elif choice==3:\n",
    "            show_calender.Show_cal()\n",
    "            ask=input(\"would you like to continue: yes/no: \")\n",
    "            if ask=='yes':\n",
    "                Crazy_list()\n",
    "            else: return\n",
    "        elif choice==4:\n",
    "            countdowntime.countdown()\n",
    "            ask=input(\"would you like to continue: yes/no: \")\n",
    "            if ask=='yes':\n",
    "                Crazy_list()\n",
    "            else: return\n",
    "        elif choice==5:\n",
    "            Music()\n",
    "            ask=input(\"would you like to continue: yes/no: \")\n",
    "            if ask=='yes':\n",
    "                Crazy_list()\n",
    "            else: return\n",
    "    else:\n",
    "        print(\"\\n#### Not in List ####\\n\")\n",
    "        Crazy_list()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "16105161",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'import random\\nfrom collections import Counter\\n\\ndef Hangman():\\n  time.sleep(2)\\n  someWords = apple banana mango strawberry\\norange grape pineapple apricot lemon coconut watermelon\\ncherry papaya berry peach lychee muskmelon\\n \\n  someWords = someWords.split(\\' \\')\\n# randomly choose a secret word from our \"someWords\" LIST.\\n  word = random.choice(someWords)        \\n \\n  if __name__ == \\'__main__\\':\\n      print(\\'Guess the word! HINT: word is a name of a fruit\\')\\n     \\n      for i in word:\\n         # For printing the empty spaces for letters of the word\\n          print(\\'_\\', end = \\' \\')       \\n      print()\\n \\n      playing = True\\n     # list for storing the letters guessed by the player\\n      letterGuessed = \\'\\'               \\n      chances = len(word) + 2\\n      correct = 0\\n      flag = 0\\n      try:\\n          while (chances != 0) and flag == 0: #flag is updated when the word is correctly guessed\\n              print()\\n              chances -= 1\\n \\n              try:\\n                  guess = str(input(\\'Enter a letter to guess: \\'))\\n              except:\\n                  print(\\'Enter only a letter!\\')\\n                  continue\\n \\n            # Validation of the guess\\n              if not guess.isalpha():\\n                  print(\\'Enter only a LETTER\\')\\n                  continue\\n              elif len(guess) > 1:\\n                  print(\\'Enter only a SINGLE letter\\')\\n                  continue\\n              elif guess in letterGuessed:\\n                  print(\\'You have already guessed that letter\\')\\n                  continue\\n \\n \\n            # If letter is guessed correctly\\n              if guess in word:\\n                  k = word.count(guess) #k stores the number of times the guessed letter occurs in the word\\n                  for _ in range(k):   \\n                      letterGuessed += guess # The guess letter is added as many times as it occurs\\n \\n            # Print the word\\n              for char in word:\\n                  if char in letterGuessed and (Counter(letterGuessed) != Counter(word)):\\n                      print(char, end = \\' \\')\\n                      correct += 1\\n                # If user has guessed all the letters\\n                  elif (Counter(letterGuessed) == Counter(word)):\\n                                                               \\n                      print(\"The word is: \", end=\\' \\')\\n                      print(word)\\n                      flag = 1\\n                      print(\\'Congratulations, You won!\\')\\n                      break # To break out of the for loop\\n                      break # To break out of the while loop\\n                  else:\\n                      print(\\'_\\', end = \\' \\')\\n \\n             \\n \\n        # If user has used all of his chances\\n          if chances <= 0 and (Counter(letterGuessed) != Counter(word)):\\n              print()\\n              print(\\'You lost! Try again..\\')\\n              print(\\'The word was {}\\'.format(word))\\n \\n      except KeyboardInterrupt:\\n          print()\\n          print(\\'Bye! Try again.\\')\\n          exit()'"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'''import random\n",
    "from collections import Counter\n",
    "\n",
    "def Hangman():\n",
    "  time.sleep(2)\n",
    "  someWords = apple banana mango strawberry\n",
    "orange grape pineapple apricot lemon coconut watermelon\n",
    "cherry papaya berry peach lychee muskmelon\n",
    " \n",
    "  someWords = someWords.split(' ')\n",
    "# randomly choose a secret word from our \"someWords\" LIST.\n",
    "  word = random.choice(someWords)        \n",
    " \n",
    "  if __name__ == '__main__':\n",
    "      print('Guess the word! HINT: word is a name of a fruit')\n",
    "     \n",
    "      for i in word:\n",
    "         # For printing the empty spaces for letters of the word\n",
    "          print('_', end = ' ')       \n",
    "      print()\n",
    " \n",
    "      playing = True\n",
    "     # list for storing the letters guessed by the player\n",
    "      letterGuessed = ''               \n",
    "      chances = len(word) + 2\n",
    "      correct = 0\n",
    "      flag = 0\n",
    "      try:\n",
    "          while (chances != 0) and flag == 0: #flag is updated when the word is correctly guessed\n",
    "              print()\n",
    "              chances -= 1\n",
    " \n",
    "              try:\n",
    "                  guess = str(input('Enter a letter to guess: '))\n",
    "              except:\n",
    "                  print('Enter only a letter!')\n",
    "                  continue\n",
    " \n",
    "            # Validation of the guess\n",
    "              if not guess.isalpha():\n",
    "                  print('Enter only a LETTER')\n",
    "                  continue\n",
    "              elif len(guess) > 1:\n",
    "                  print('Enter only a SINGLE letter')\n",
    "                  continue\n",
    "              elif guess in letterGuessed:\n",
    "                  print('You have already guessed that letter')\n",
    "                  continue\n",
    " \n",
    " \n",
    "            # If letter is guessed correctly\n",
    "              if guess in word:\n",
    "                  k = word.count(guess) #k stores the number of times the guessed letter occurs in the word\n",
    "                  for _ in range(k):   \n",
    "                      letterGuessed += guess # The guess letter is added as many times as it occurs\n",
    " \n",
    "            # Print the word\n",
    "              for char in word:\n",
    "                  if char in letterGuessed and (Counter(letterGuessed) != Counter(word)):\n",
    "                      print(char, end = ' ')\n",
    "                      correct += 1\n",
    "                # If user has guessed all the letters\n",
    "                  elif (Counter(letterGuessed) == Counter(word)):\n",
    "                                                               \n",
    "                      print(\"The word is: \", end=' ')\n",
    "                      print(word)\n",
    "                      flag = 1\n",
    "                      print('Congratulations, You won!')\n",
    "                      break # To break out of the for loop\n",
    "                      break # To break out of the while loop\n",
    "                  else:\n",
    "                      print('_', end = ' ')\n",
    " \n",
    "             \n",
    " \n",
    "        # If user has used all of his chances\n",
    "          if chances <= 0 and (Counter(letterGuessed) != Counter(word)):\n",
    "              print()\n",
    "              print('You lost! Try again..')\n",
    "              print('The word was {}'.format(word))\n",
    " \n",
    "      except KeyboardInterrupt:\n",
    "          print()\n",
    "          print('Bye! Try again.')\n",
    "          exit()'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "8f029d34",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'\\ndef RPS():\\n    possible_actions = [\"rock\", \"paper\", \"scissors\"]\\n    print(\"\\n < To Quit the game Press: end> \\n\")\\n    while True:\\n        user_action = input(\"Enter a choice (rock, paper, scissors): \")\\n        if user_action == \\'quit\\':\\n            break\\n        computer_action = random.choice(possible_actions)\\n        print(f\"\\nYou chose {user_action}, computer chose {computer_action}.\\n\")\\n        if user_action == \\'end\\':\\n            break\\n        if user_action == computer_action:\\n            print(f\"Both players selected {user_action}. It\\'s a tie!\")\\n        elif user_action == \"rock\":\\n            if computer_action == \"scissors\":\\n                print(\"Rock smashes scissors! You win!\")\\n            else:\\n                print(\"Paper covers rock! You lose.\")\\n        elif user_action == \"paper\":\\n            if computer_action == \"rock\":\\n                print(\"Paper covers rock! You win!\")\\n            else:\\n                print(\"Scissors cuts paper! You lose.\")\\n        elif user_action == \"scissors\":\\n            if computer_action == \"paper\":\\n                print(\"Scissors cuts paper! You win!\")\\n            else:\\n                print(\"Rock smashes scissors! You lose.\")'"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# --- Rock Paper Scissor Game --- \n",
    "'''\n",
    "def RPS():\n",
    "    possible_actions = [\"rock\", \"paper\", \"scissors\"]\n",
    "    print(\"\\n < To Quit the game Press: end> \\n\")\n",
    "    while True:\n",
    "        user_action = input(\"Enter a choice (rock, paper, scissors): \")\n",
    "        if user_action == 'quit':\n",
    "            break\n",
    "        computer_action = random.choice(possible_actions)\n",
    "        print(f\"\\nYou chose {user_action}, computer chose {computer_action}.\\n\")\n",
    "        if user_action == 'end':\n",
    "            break\n",
    "        if user_action == computer_action:\n",
    "            print(f\"Both players selected {user_action}. It's a tie!\")\n",
    "        elif user_action == \"rock\":\n",
    "            if computer_action == \"scissors\":\n",
    "                print(\"Rock smashes scissors! You win!\")\n",
    "            else:\n",
    "                print(\"Paper covers rock! You lose.\")\n",
    "        elif user_action == \"paper\":\n",
    "            if computer_action == \"rock\":\n",
    "                print(\"Paper covers rock! You win!\")\n",
    "            else:\n",
    "                print(\"Scissors cuts paper! You lose.\")\n",
    "        elif user_action == \"scissors\":\n",
    "            if computer_action == \"paper\":\n",
    "                print(\"Scissors cuts paper! You win!\")\n",
    "            else:\n",
    "                print(\"Rock smashes scissors! You lose.\")'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "8ce70878",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'\\ndef GuessNumGame():\\n\\tprint(\"****\\tGuess Number Game\\t****\")\\n\\tnum=random.randint(1,100)\\n\\tcount=5\\n\\tfind=False\\n\\tprint(\"\\n\\tYou Have only 5 attempt to Win..\")\\n\\twhile count>=1:\\n\\t\\tuser=int(input(\"Enter Your number(1-100): \"))\\n\\t\\tif 0<user<100:\\n\\t\\t\\tif user<num:\\n\\t\\t\\t\\tprint(\"\\t Your number is smaller than the Secret Number\")\\n\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\tprint(\"You have only \",count, \"attempt left\")\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telif user>num:\\n\\t\\t\\t\\tprint(\"\\t Your number is greater than the Secret Number\")\\n\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\tprint(\"You have only \",count, \"attempt left\")\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telif user==num:\\n\\t\\t\\t\\tprint(\"\\n*$*\\tYou Got it\\t*$*\")\\n\\t\\t\\t\\tfind=True\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tprint(\":(  Wrong Input! \")\\n\\n\\tif find==False:\\n\\t\\tprint(\"\\t:( YOU FAILED :(\")\\n\\t\\tprint(\"The Secret Number is \",num)\\n\\telse:\\n\\t\\tprint(\" :) Congrants\")\\n'"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# --- Guess Number Game ---\n",
    "'''\n",
    "def GuessNumGame():\n",
    "\tprint(\"****\\tGuess Number Game\\t****\")\n",
    "\tnum=random.randint(1,100)\n",
    "\tcount=5\n",
    "\tfind=False\n",
    "\tprint(\"\\n\\tYou Have only 5 attempt to Win..\")\n",
    "\twhile count>=1:\n",
    "\t\tuser=int(input(\"Enter Your number(1-100): \"))\n",
    "\t\tif 0<user<100:\n",
    "\t\t\tif user<num:\n",
    "\t\t\t\tprint(\"\\t Your number is smaller than the Secret Number\")\n",
    "\t\t\t\tcount-=1\n",
    "\t\t\t\tprint(\"You have only \",count, \"attempt left\")\n",
    "\t\t\t\tcontinue\n",
    "\t\t\telif user>num:\n",
    "\t\t\t\tprint(\"\\t Your number is greater than the Secret Number\")\n",
    "\t\t\t\tcount-=1\n",
    "\t\t\t\tprint(\"You have only \",count, \"attempt left\")\n",
    "\t\t\t\tcontinue\n",
    "\t\t\telif user==num:\n",
    "\t\t\t\tprint(\"\\n*$*\\tYou Got it\\t*$*\")\n",
    "\t\t\t\tfind=True\n",
    "\t\t\t\tbreak\n",
    "\t\telse:\n",
    "\t\t\tprint(\":(  Wrong Input! \")\n",
    "\n",
    "\tif find==False:\n",
    "\t\tprint(\"\\t:( YOU FAILED :(\")\n",
    "\t\tprint(\"The Secret Number is \",num)\n",
    "\telse:\n",
    "\t\tprint(\" :) Congrants\")\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "ad216c7d",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'\\ndef CalculationGame():\\n  print(\"\\tCALCULATION GAME \\t\".center(50,\\'*\\'))\\n  print(\\'\\nSolve These and earn Score <1 correct earn 1 score>\\n\\')\\n  count=0\\n  l=[\\'*\\',\\'+\\',\\'-\\',\\'%\\']\\n  while True:\\n      a=random.randint(1,20)\\n      b=random.randint(1,20)\\n      random_cal=random.choice(l)\\n      print(a , random_cal , b , \\'=\\' ,end=\\' \\')\\n      usr=int(input())\\n      if random_cal==\\'+\\':\\n          if a+b==usr:\\n              print(\"\\tcorrect :)  \")\\n              count+=1\\n          else:\\n              print(\\'\\t:( Wrong :(\\')\\n              break\\n      elif random_cal==\\'-\\':\\n          if a-b==usr:\\n              print(\"\\tcorrect :)  \")\\n              count+=1\\n          else:\\n              print(\\'\\t:( Wrong :(\\')\\n              break\\n      elif random_cal==\\'*\\':\\n          if a*b==usr:\\n              print(\"\\tcorrect :)  \")\\n              count+=1\\n          else:\\n              print(\\'\\t:( Wrong :(\\')\\n              break\\n      elif random_cal==\\'%\\':\\n          if a%b==usr:\\n              print(\"\\tcorrect :)  \")\\n              count+=1\\n          else:\\n              print(\\'\\t:( Wrong :(\\')\\n              break\\n    \\n  print(\\'Total Score = \\', count)'"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# <<<<<<  CALCULATION GAME  >>>>>>>>\n",
    "'''\n",
    "def CalculationGame():\n",
    "  print(\"\\tCALCULATION GAME \\t\".center(50,'*'))\n",
    "  print('\\nSolve These and earn Score <1 correct earn 1 score>\\n')\n",
    "  count=0\n",
    "  l=['*','+','-','%']\n",
    "  while True:\n",
    "      a=random.randint(1,20)\n",
    "      b=random.randint(1,20)\n",
    "      random_cal=random.choice(l)\n",
    "      print(a , random_cal , b , '=' ,end=' ')\n",
    "      usr=int(input())\n",
    "      if random_cal=='+':\n",
    "          if a+b==usr:\n",
    "              print(\"\\tcorrect :)  \")\n",
    "              count+=1\n",
    "          else:\n",
    "              print('\\t:( Wrong :(')\n",
    "              break\n",
    "      elif random_cal=='-':\n",
    "          if a-b==usr:\n",
    "              print(\"\\tcorrect :)  \")\n",
    "              count+=1\n",
    "          else:\n",
    "              print('\\t:( Wrong :(')\n",
    "              break\n",
    "      elif random_cal=='*':\n",
    "          if a*b==usr:\n",
    "              print(\"\\tcorrect :)  \")\n",
    "              count+=1\n",
    "          else:\n",
    "              print('\\t:( Wrong :(')\n",
    "              break\n",
    "      elif random_cal=='%':\n",
    "          if a%b==usr:\n",
    "              print(\"\\tcorrect :)  \")\n",
    "              count+=1\n",
    "          else:\n",
    "              print('\\t:( Wrong :(')\n",
    "              break\n",
    "    \n",
    "  print('Total Score = ', count)'''\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "b342c9a2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# function to start the chat bot which will continue till the user type 'end'\n",
    "\n",
    "def start_chat():\n",
    "    print(\"Hello! I am your Alien Bot. Let's have a conversation! If you want to exit any time, just type end!\\n\\n\")\n",
    "    exit_pole=['exit','break','quit','see you later','chat with you later','end the chat','bye','ok bye','end']\n",
    "    while True:\n",
    "        inp = str(input(\">>\")).lower()\n",
    "        if inp.lower()== 'list':\n",
    "          Crazy_list()\n",
    "          continue\n",
    "        if inp.lower() in exit_pole:\n",
    "            print(\" :) OK BYE :) \")\n",
    "            break\n",
    "        if inp.lower()== '' or inp.lower()== '*':\n",
    "            print('Please re-phrase your query!')\n",
    "            print(\"-\"*50)\n",
    "        else:\n",
    "            print(f\"Alien: {chatbot_response(inp)}\"+'\\n')\n",
    "            print(\"-\"*50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "a066a70b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello! I am your Alien Bot. Let's have a conversation! If you want to exit any time, just type end!\n",
      "\n",
      "\n",
      ">>how are you\n",
      "Alien: Hi there, how can I help?\n",
      "\n",
      "--------------------------------------------------\n",
      ">>who are you\n",
      "Alien: Hi my name is Alien, your virtual assistant\n",
      "\n",
      "--------------------------------------------------\n",
      ">>how you help\n",
      "Alien: We both can chat and make each other happy\n",
      "\n",
      "--------------------------------------------------\n",
      ">>good\n",
      "Alien: Hi there, how can I help?\n",
      "\n",
      "--------------------------------------------------\n",
      ">>what can you do\n",
      "Alien: I can answer your questions related to machine learning or any general anser. Come on try me\n",
      "\n",
      "--------------------------------------------------\n",
      ">>what are your hobbies\n",
      "Alien: I don't know...what I do know is that I would like to NOT grace your dumb question with an answer because FYI in case it has slipped your mind....I'm a bot!\n",
      "\n",
      "--------------------------------------------------\n",
      ">>how can you chat\n"
     ]
    },
    {
     "ename": "IndexError",
     "evalue": "list index out of range",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mIndexError\u001b[0m                                Traceback (most recent call last)",
      "Input \u001b[1;32mIn [43]\u001b[0m, in \u001b[0;36m<cell line: 1>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43mstart_chat\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n",
      "Input \u001b[1;32mIn [41]\u001b[0m, in \u001b[0;36mstart_chat\u001b[1;34m()\u001b[0m\n\u001b[0;32m     16\u001b[0m     \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m-\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;241m*\u001b[39m\u001b[38;5;241m50\u001b[39m)\n\u001b[0;32m     17\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m---> 18\u001b[0m     \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mAlien: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mchatbot_response(inp)\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;241m+\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;124m'\u001b[39m)\n\u001b[0;32m     19\u001b[0m     \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m-\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;241m*\u001b[39m\u001b[38;5;241m50\u001b[39m)\n",
      "Input \u001b[1;32mIn [26]\u001b[0m, in \u001b[0;36mchatbot_response\u001b[1;34m(text)\u001b[0m\n\u001b[0;32m     15\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mchatbot_response\u001b[39m(text):\n\u001b[0;32m     16\u001b[0m     ints \u001b[38;5;241m=\u001b[39m predict_class(text, model)\n\u001b[1;32m---> 17\u001b[0m     res \u001b[38;5;241m=\u001b[39m \u001b[43mgetResponse\u001b[49m\u001b[43m(\u001b[49m\u001b[43mints\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mintents\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     18\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m res\n",
      "Input \u001b[1;32mIn [26]\u001b[0m, in \u001b[0;36mgetResponse\u001b[1;34m(ints, intents_json)\u001b[0m\n\u001b[0;32m      3\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mgetResponse\u001b[39m(ints, intents_json):\n\u001b[1;32m----> 4\u001b[0m     tag \u001b[38;5;241m=\u001b[39m \u001b[43mints\u001b[49m\u001b[43m[\u001b[49m\u001b[38;5;241;43m0\u001b[39;49m\u001b[43m]\u001b[49m[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mintent\u001b[39m\u001b[38;5;124m'\u001b[39m]\n\u001b[0;32m      5\u001b[0m     list_of_intents \u001b[38;5;241m=\u001b[39m intents_json[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mintents\u001b[39m\u001b[38;5;124m'\u001b[39m]\n\u001b[0;32m      6\u001b[0m     \u001b[38;5;28;01mfor\u001b[39;00m i \u001b[38;5;129;01min\u001b[39;00m list_of_intents:\n",
      "\u001b[1;31mIndexError\u001b[0m: list index out of range"
     ]
    }
   ],
   "source": [
    " start_chat()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "d2e5fd77",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Exception in Tkinter callback\n",
      "Traceback (most recent call last):\n",
      "  File \"c:\\users\\kush\\appdata\\local\\programs\\python\\python38\\lib\\tkinter\\__init__.py\", line 1892, in __call__\n",
      "    return self.func(*args)\n",
      "  File \"C:\\Users\\kush\\AppData\\Local\\Temp\\ipykernel_2244\\3277788717.py\", line 53, in send_msz\n",
      "    lab = f\"Bot: {chatbot_response(usr_input)}\"+'\\n'\n",
      "  File \"C:\\Users\\kush\\AppData\\Local\\Temp\\ipykernel_2244\\1147065555.py\", line 17, in chatbot_response\n",
      "    res = getResponse(ints, intents)\n",
      "  File \"C:\\Users\\kush\\AppData\\Local\\Temp\\ipykernel_2244\\1147065555.py\", line 4, in getResponse\n",
      "    tag = ints[0]['intent']\n",
      "IndexError: list index out of range\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "import tkinter as tk\n",
    "from tkinter import *\n",
    "\n",
    "root=tk.Tk()\n",
    "filename=\"Chat Bot\"\n",
    "root.title(f\"Chat Bot\")\n",
    "root.geometry('500x400')\n",
    "root.resizable(True , True)\n",
    "message=tk.StringVar()\n",
    "\n",
    "chat_win=Frame(root,bd=1,bg='white',width=50,height=8)\n",
    "chat_win.place(x=6,y=6,height=300,width=488)\n",
    "\n",
    "textcon=tk.Text(chat_win,bd=1,bg='white',width=50,height=8)\n",
    "textcon.pack(fill=\"both\",expand=True)\n",
    "\n",
    "mes_win=Entry(root,width=30,xscrollcommand=True,textvariable=message)\n",
    "mes_win.place(x=6,y=310,height=60,width=380)\n",
    "mes_win.focus()\n",
    "\n",
    "textcon.config(fg='black')\n",
    "textcon.tag_config('usr',foreground='black')\n",
    "textcon.insert(END,\"Bot: This is Alien! Your Personal Assistant.\\n\\n\")\n",
    "mssg=mes_win.get()\n",
    "\n",
    "exit_list = ['exit','break','quit','see you later','chat with you later','end the chat','bye','ok bye','end']\n",
    "\n",
    "def greet_res(text):\n",
    "    text=text.lower()\n",
    "    bot_greet=['hi','hello','hola','hey','howdy']\n",
    "    usr_greet=['hi','hey','hello','hola','greetings','wassup','whats up','hii']\n",
    "    for word in text.split():\n",
    "        if word in usr_greet:\n",
    "            return random.choice(bot_greet)\n",
    "\n",
    "def send_msz(event=None):\n",
    "    usr_input = message.get()\n",
    "    usr_input = usr_input.lower()\n",
    "    textcon.insert(END, f'You: {usr_input}'+'\\n','usr')\n",
    "    if usr_input in exit_list:\n",
    "        textcon.config(fg='black')\n",
    "        textcon.insert(END, \"Ok bye! see you later.\\n\\n\")\n",
    "        time.sleep(1)\n",
    "        return root.destroy()\n",
    "    else:\n",
    "        textcon.config(fg='black')\n",
    "        if greet_res(usr_input) != None:\n",
    "            lab=f\"Bot: {greet_res(usr_input)}\"+'\\n'\n",
    "            textcon.insert(END,lab)\n",
    "            mes_win.delete(0,END)\n",
    "        else:\n",
    "            lab = f\"Bot: {chatbot_response(usr_input)}\"+'\\n'\n",
    "            textcon.insert(END,lab)\n",
    "            mes_win.delete(0,END)\n",
    "\n",
    "button_send=Button(root,text='Send',bg='dark green',activebackground='grey',command=send_msz,width=12,height=5,font=('Arial'))\n",
    "button_send.place(x=376,y=310,height=60,width=110)\n",
    "root.bind('<Return>', send_msz,button_send)\n",
    "root.mainloop()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
